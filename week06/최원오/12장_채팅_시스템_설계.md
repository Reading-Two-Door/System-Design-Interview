# 채팅 시스템 설계

## 1단계 문제 이해 및 설계 범위 확정

- 어떤 채팅 앱을 설계하려는지 확실하게 하자

## 2단계 개략적 설계안 제시 및 동의 구하기

- 클라이언트는 서로 직접 통신하지 않는다. 채팅 서비스와 통신
- 채팅 서비스는 아래 기능 제공
  - 클라이언트들로 부터 메시지 수신
  - 메시지 수신자 결정 및 전달
  - 수신자가 접속 상태가 아닌 경우에 접속할 때까지 메시지 보관
- 송신 과정에서 HTTP 프로토콜로 연결 후 keep-alive 헤더를 사용하면 효율적, 하지만 수신 시나리오는 복잡하다.
- 서버가 연결을 만드는 것처럼 동작할 수 있도록 많은 기법이 제안되어 왔는데, 폴링, 롱 폴링, 웹소켓 등이 그런 기술이다.

### 폴링

- 주기적으로 서버에게 새 메세지가 있는지 확인하는 방법
- 폴링을 자주하면 폴링 비용이 올라간다.
- 답해줄 메시지가 없는 경우 서버자원이 낭비되는 문제가 있다.

### 롱 폴링

- 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지
- 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작
- 송신자와 수신자가 같은 채팅 서버에 접속하게 되지 않을 수 있다. 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.
- 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때 마다 주기적으로 서버에 다시 접속이 필요

### 웹소켓

- 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
- 연결은 클라이언트가 시작한다.
- 한 번 맺어진 연결은 항구적(변하지 아니하고 오래가는 것)이며 양방향이다.
- 처음 연결은 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드 된다.
- 메시지를 송수신 시 동일한 프로토콜을 사용할 수 있으므로 설계뿐 아니라 구현도 단순하고 직관적이다.
- 연결은 항구적으로 유지되어야하기에 서버 측에서 연결관리를 효율적으로 해야한다.

무상태 서비스

- 회원가입, 로그인 등 전통적인 요청/응답 서비스
- 무상태 서비스는 로드밸런서 뒤에 위치한다.
- 서비스 탐색 - 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할

상태 유지 서비스

- 채팅 서비스
- 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문
- 서비스 탐색 서비스는 채팅 서비스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.

제 3자 서비스 연동

- 푸시 알림

규모 확장성

- 서버 한 대로 얼마나 많은 접속을 동시에 허용할 수 있냐
- 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할
- 접속 상태 서버는 사용자의 접속 여부 관리
- 키 값 저장소로 채팅 이력 보관

저장소

- 사용자 프로파일, 설정, 친구 목록 등 일반적인 데이터 - 안정성을 보관하는 관계형 데이터베이스
- 채팅 이력 - 키값 저장소 추천
  - 수평적 규모 확장이 쉽다.
  - 데이터 접근 시간이 낮다.

### 데이터 모델

- 1:1은 message_from
- 그룹채팅은 channel_id

메시지 ID

- 유니크
- 정렬 가능해야하며 시간 순서 일치해야 한다. (스노플레이크, 지역적 순서 번호 생성기)

## 3단계 상세 설계

### 서비스 탐색

- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
- 클라이언트 위치, 서버의 용량
- 아파치 주키퍼 같은 솔루션을 통해 최적의 서버를 탐색

### 메시지 흐름

1:1 채팅 메시지 처리 흐름

- 다른 채팅 서버 접속? 네임스페이스나 룸에 어떻게 접근???????????????????

여러 단말 사이에 메시지 동기화

- cur_max_message_id 로 단말의 가장 최신 메시지 관리

소규모 그룹 채팅에서의 메시지 흐름

- 유저별 메시지 동기화 큐를 가짐
  - 새로운 메시지 확인 시 자기 큐만 확인하면 동기화가 단순
  - 소규모 이기에 수신자별 큐에 넣는 작업 비용이 크지 않다
- 메시지 동기화 큐는 여러 사용자로 부터 오는 메시지를 받을 수 있어야 한다.

### 접속상태 표시

- 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부

사용자 로그인

- 클라이언트와 웹소켓 연결이 맺어지고 나면 last_active_at 타임스탬프 값을 키-값 저장소에 보관

로그아웃

- 키-값 저장소에 보관된 사용자 상태가 online에서 offline으로 변경

접속장애

- 네트워크 접속으로 인해 온오프가 계속 변경되면 좋지 않으므로 하트비트 이벤트로 미수신하는 경우 오프라인 처리

상태 정보의 전송

- 상태정보 서버는 발행-구독 모델을 사용, 각각의 친구관계마다 채널을 하나씩 두는 것
- 그룹 크기가 적은 경우에 효과적

## 4단계 마무리

- 사진이나 비디오 등의 미디어를 지원하도록 하는 방법
- 종단 간 암호화
- 캐시
- 로딩 속도 개선
- 오류 처리
