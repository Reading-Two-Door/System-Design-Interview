# 사용자 수에 따른 규모 확장성

## 단일 서버

### 사용자 요청 처리 흐름

1. url을 통해 웹사이트에 접속하면 DNS를 통해 IP 주소로 변환한다.
2. 해당 IP 주소로 HTTP 요청이 전달된다.
3. 요청을 받은 웹 서버는 HTML 이나 JSON 형태의 응답을 반환한다.

## 데이터베이스

- 사용자가 늘면 서버 하나로는 충분하지 않아 여러 서버를 두어야 한다. 하나는 웹/모바일 트래픽 처리 용도고, 다른 하나는 데이터베이스용이다.

### 어떤 데이터베이스를 사용할 것인가?

#### SQL

- 관계형 데이터베이스와 비관계형 데이터베이스가 있다.
- 관계형 데이터베이스는 자료를 테이블과 열, 칼럼으로 표현한다. 여러 테이블에 있는 데이터를 그 관계에 따라 조인하여 합칠 수 있다.

#### NoSQL

- NoSQL은 네 부류로 나눌 수 있는데, 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소가 있다.
- NoSQL이 유용한 경우
  - 아주 낮은 응답 지연시간이 요구됨
    - 예시: 실시간 주식 거래 플랫폼
    - 구체적 상황: 주식 가격이 밀리초 단위로 변동되며, 트레이더들은 이 정보를 즉시 필요로 합니다. NoSQL 데이터베이스(예: Redis)는 인메모리 저장소를 사용하여 microsecond 수준의 응답 시간을 제공할 수 있습니다.
  - 다루는 데이터가 비정형이라 관계형 데이터가 아님
    - 예시: 소셜 미디어 플랫폼의 사용자 프로필 데이터
    - 구체적 상황: 사용자마다 다른 정보를 저장할 수 있습니다. 어떤 사용자는 취미, 학력, 직업 정보를 모두 가질 수 있고, 다른 사용자는 이 중 일부만 가질 수 있습니다. MongoDB와 같은 문서 기반 NoSQL 데이터베이스는 이러한 가변적인 구조를 쉽게 저장할 수 있습니다.
  - 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
    - 예시: IoT(사물인터넷) 디바이스의 센서 데이터 저장
    - 구체적 상황: 다양한 종류의 센서(온도, 습도, 압력 등)에서 데이터가 JSON 형식으로 전송됩니다. Cassandra와 같은 NoSQL 데이터베이스는 이러한 JSON 데이터를 그대로 저장하고, 필요할 때 역직렬화하여 사용할 수 있습니다.
  - 아주 많은 양의 데이터를 저장할 필요가 있음
    - 예시: 대규모 로그 분석 시스템
    - 구체적 상황: 대형 e-커머스 플랫폼에서 매일 수백 기가바이트의 사용자 활동 로그가 생성됩니다. 이를 분석하여 사용자 행동 패턴을 파악하고 싶습니다. HBase나 Cassandra와 같은 NoSQL 데이터베이스는 수평적 확장이 용이하여 페타바이트 수준의 데이터도 효율적으로 저장하고 분석할 수 있습니다.

#### NoSQL이 적합한 상황에서 RDBMS(관계형 데이터베이스 관리 시스템)를 사용할 경우 발생할 수 있는 주요 문제점

1. 성능 저하

   - 대량의 데이터를 처리할 때 RDBMS는 복잡한 조인 연산이나 트랜잭션 처리로 인해 성능이 저하될 수 있습니다.
   - 예: 소셜 미디어 플랫폼에서 사용자 활동 로그를 초당 수만 건씩 저장해야 할 때, RDBMS는 병목 현상을 일으킬 수 있습니다.

2. 스키마 변경의 어려움

   - RDBMS는 엄격한 스키마를 요구하므로, 데이터 구조 변경 시 전체 테이블을 수정해야 할 수 있습니다.
   - 예: 사용자 프로필에 새로운 필드를 추가할 때마다 테이블 구조를 변경하고 기존 데이터를 마이그레이션해야 합니다.

3. 수평적 확장의 한계

   - RDBMS는 주로 수직적 확장(더 강력한 하드웨어 사용)에 의존하며, 수평적 확장(더 많은 서버 추가)이 어렵습니다.
   - 예: 대규모 IoT 시스템에서 데이터양이 급증할 때, 단순히 서버를 추가하는 것으로는 확장이 어려울 수 있습니다.

4. 높은 지연 시간

   - 복잡한 쿼리와 트랜잭션 처리로 인해 응답 시간이 길어질 수 있습니다.
   - 예: 실시간 게임 서버에서 플레이어 상태 업데이트가 지연되어 사용자 경험이 저하될 수 있습니다.

5. 비정형 데이터 처리의 비효율성

   - RDBMS는 구조화된 데이터에 최적화되어 있어, 비정형 데이터를 효율적으로 저장하고 검색하기 어렵습니다.
   - 예: 다양한 형식의 센서 데이터를 저장할 때, 각 센서 유형마다 별도의 테이블을 만들어야 할 수 있어 복잡성이 증가합니다.

6. 개발 및 유지보수의 복잡성

   - 비정형 데이터를 RDBMS에 맞추기 위해 복잡한 테이블 구조와 쿼리를 설계해야 할 수 있습니다.
   - 예: 문서 기반 데이터를 여러 테이블로 분할하여 저장하면, 데이터 조회 시 복잡한 조인 연산이 필요할 수 있습니다.

7. 비용 증가

   - 대규모 데이터 처리를 위해 고성능 하드웨어가 필요할 수 있으며, 라이선스 비용도 증가할 수 있습니다.
   - 예: 빅데이터 분석 시스템에서 RDBMS를 사용할 경우, 고가의 엔터프라이즈급 솔루션이 필요할 수 있습니다.

8. 유연성 부족
   - 새로운 유형의 데이터나 관계를 추가하기 위해서는 전체 데이터베이스 구조를 재설계해야 할 수 있습니다.
   - 예: 소셜 네트워크에서 새로운 유형의 사용자 연결을 추가할 때, 기존 테이블 구조를 크게 변경해야 할 수 있습니다.

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장

- 스케일 업 - 서버에 고사양 자원을 추가하는 행위
- 서버로 유입되는 트래픽 양이 적은 경우 좋은 선택
- 수직적 규모 확장의 단점
  - 확장에 한계가 있다. 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없다.
  - 서버에 장애가 발생하면 애플리케이션은 완전히 중단된다.

### 수평적 규모 확장

- 스케일 아웃 - 더 많은 서버를 추가하여 성능을 개선하는 행위
- 대규모 애플리케이션을 지원하는데 좋은 선택

### 로드밸런서

- 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.
- 사용자는 로드밸런스의 공개 IP주소로 접근한다.
- 서버 간 통신에는 프라이빗 IP 주소가 이용된다. 프라이빗 IP는 같은 네트워크에 속한 서버 사이의 통신에만 쓸 수 있는 IP주소로 인터넷을 통해 접근할 수는 없다.
- 부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 장애 자동복구 (no failove)는 해소되며, 웹 계층의 가용성은 향상된다.
  - 서버1이 다운되면 모든 트래픽은 서버2로 전송되며 사이트 전체가 다운되는 일이 방지된다.
  - 트래픽을 감당할 수 없는 시점이 오면, 웹 서버 계층에 더 많은 서버를 추가하면 로드밸런서를 통해 트래픽을 분산할 수 있다.

### 데이터베이스 다중화

- 서버 사이에 주-부 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식을 사용한다.
- write는 주 데이터베이스에서만 지원한다. 부 데이터베이스는 read만을 지원한다.
- 대부분의 애플리케이션은 read의 비중이 높다. 따라서 부 데이터베이스의 수가 많다.

#### 데이터베이스 다중화로 얻는 이득

- 성능 향샹 - 병렬로 처리될 수 있는 쿼리 수가 늘어나므로, 성능이 좋아진다.
- 안정성 - 데이터베이스 서버 가운데 일부가 파괴되어도 안정적으로 데이터를 보존할 수 있다.
- 가용성 - 데이터를 여러 지역에 복제함으로써 하나의 데이터베이스에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 서비스가 가능하다.

## 캐시

- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤 이은 요청이 빨리 처리될 수 있도록 하는 저장소

### 캐시 계층

- 캐시 계층은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.
- 앍기 주도형 캐시 전략 - 요청이 들어오면 웹 서버는 캐시에 응답이 있는지 확인 후 있으면 반환하고 없으면 데이터베이스에 질의한다.
- 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

### 캐시 사용 시 유의할 점

- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우
- 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- 캐시 데이터의 만료에 대한 정책이 필요하다.
- 데이터 저장소의 원본과 캐시 내의 사본이 같은지
- 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(SPOF)이 되어버릴 가능성이 있다.
  - SPOF - 단일 서버 장애 지점은 시스템의 한 부분이 실패할 경우 전체 시스템의 작동이 중단되는 지점을 말합니다. 즉, 이 부분이 고장나면 전체 시스템이 멈추거나 심각한 장애를 겪게 됩니다.
- 캐시 메모리를 얼마나 크게 잡을 것인가 - 오버프로비저닝은 예상되는 최대 부하나 요구사항보다 더 많은 리소스를 할당하는 전략
- 데이터 방출 정책 - LFU(사용 빈도가 가장 낮은 데이터 방출), LRU(가장 오래전 사용된 데이터 방출), FIFO

## 콘텐츠 전송 네트워크(CDN)

- CDN은 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크이다.
- 유저가 웹사이트에 접근 시, 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하게 된다.
- CDN 서버의 캐시에 콘텐츠가 없는 경우 원 서버에 요청하여 캐시 후 사용자에게 반환한다.

### CDN 사용 시 고려해야 할 사항

- 비용
- 만료 시한
- CDN 장애에 대한 대처 방안
- 콘텐츠 무효화 방법

## 무상태 웹 계층

### 상태 정보 의존적인 아키텍처

- 상태 정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다.
- 같은 클라이언트 요청은 항상 같은 서버로 전송되어야 한다. 대부분의 로드밸런서는 고정 세션 기능을 제공하지만 부담을 준다.

### 무상태 아키텍처

- 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다.

## 데이터 센터

- 유저를 가장 가까운 데이터 센터로 안내하는데, 이 절차를 지리적 라우팅이라고 부른다.

### 다중 데이터센터의 기술적 난제

- 트래픽 우회 - 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야한다.
- 데이터 동기화 - 데이터 센터마다 별도의 데이터베이스를 사용한다면 데어터를 여러 데이터센터에 걸쳐 다중화하는 것이 필요하다.
- 테스트와 배포
- 규모 확장을 위해서는 시스템 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있어야한다. 메시지 큐는 많은 실제 분산 시스템이 채용하는 전략 중 하나이다.

## 메시지 큐

- 메시지 큐는 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트다. 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.
- 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

## 로그, 메트릭 그리고 자동화

### 로그

- 에러 로그는 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.

### 메트릭

- 비즈니스 측정치와 핵심 실적 지표를 나타내는 MicroStrategy 개체

- 호스트 단위 메트릭 - CPU, 메모리, 디스크 I/O
- 종합 메트릭 - 데이터베이스 계층의 성능, 캐시 계층의 성능
- 핵심 비지니스 메트릭 - DAU, 레비뉴, 리텐션

### 자동화

- CI/CD

## 데이터베이스의 규모 확장

### 수직적 확장

- 스케일 업
- 확장의 한계가 있고, SPOF로 인한 위험성이 크며, 비용 부담이 있을 수 있다.

### 수평적 확장

- 샤딩 - 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.
- 샤딩 키는 파티션 키라고도 부르며, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다.

#### 샤딩 도입 시 발생하는 문제

- 리샤딩
  - 데이터가 많아져 하나의 샤드로 감당이 어려울 때
  - 샤드 간 데이터 분포가 불균등할 때
- 셀러브리티 문제
  - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
- 조인과 비정규화
  - 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다.

#### 샤딩 vs 스케일 아웃

서버의 수평적 확장(스케일 아웃)과 데이터베이스의 수평적 확장(샤딩)은 비슷한 개념이지만, 용어가 다른 이유가 있습니다. 이에 대해 자세히 설명드리겠습니다.

1. 개념적 유사성:

   - 두 용어 모두 수평적 확장을 의미합니다.
   - 더 많은 노드나 서버를 추가하여 시스템의 용량과 성능을 향상시킵니다.

2. 용어의 차이:
   a) 스케일 아웃 (Scale-out):

   - 주로 애플리케이션 서버나 웹 서버에 적용됩니다.
   - 동일한 기능을 수행하는 서버를 추가합니다.
   - 로드 밸런서를 통해 트래픽을 분산시킵니다.

   b) 샤딩 (Sharding):

   - 데이터베이스 시스템에 특화된 용어입니다.
   - 데이터를 여러 서버에 분산 저장하는 기술을 의미합니다.
   - 각 샤드(shard)는 전체 데이터의 부분집합을 저장합니다.

3. 차이점의 이유:
   a) 데이터 처리 방식의 차이:

   - 스케일 아웃: 각 서버가 모든 요청을 동등하게 처리할 수 있습니다.
   - 샤딩: 각 데이터베이스 서버(샤드)가 특정 데이터 subset만을 처리합니다.

   b) 복잡성의 차이:

   - 스케일 아웃: 상대적으로 단순한 로드 밸런싱으로 구현 가능합니다.
   - 샤딩: 데이터 분할, 라우팅, 일관성 유지 등 복잡한 메커니즘이 필요합니다.

   c) 목적의 차이:

   - 스케일 아웃: 주로 처리 능력(compute power) 향상에 초점을 맞춥니다.
   - 샤딩: 대용량 데이터 처리와 저장 능력 향상에 중점을 둡니다.

   d) 역사적 배경:

   - 스케일 아웃: 웹 서비스의 발전과 함께 일반화된 용어입니다.
   - 샤딩: 대규모 데이터베이스 시스템의 필요성이 커지면서 발전한 특화된 기술입니다.

4. 구현의 차이:

   - 스케일 아웃: 로드 밸런서를 통한 요청 분배가 주요 메커니즘입니다.
   - 샤딩: 데이터 파티셔닝 전략, 샤드 키 선택, 데이터 마이그레이션 등 복잡한 과정이 필요합니다.

5. 관리의 차이:

   - 스케일 아웃: 서버 추가/제거가 상대적으로 간단합니다.
   - 샤딩: 데이터 재분배, 샤드 밸런싱 등 더 복잡한 관리가 필요합니다.

6. 사용 사례:
   - 스케일 아웃: 웹 서버, 애플리케이션 서버, 마이크로서비스 등
   - 샤딩: 대규모 데이터베이스, 분산 저장 시스템 등

결론적으로, 두 용어의 차이는 주로 적용 대상과 구현 방식의 차이에서 비롯됩니다. 스케일 아웃은 일반적인 서버 확장 전략을 나타내는 반면, 샤딩은 데이터베이스 시스템에 특화된 더 복잡하고 세분화된 확장 전략을 의미합니다. 이러한 구분은 각 영역의 특성과 요구사항을 더 정확히 반영하기 위해 발전해 왔습니다.

## 백만 사용자, 그리고 그 이상

- 시스템 규모를 확장하는 것은 지속적이고 반복적인 과정이다.
- 수백만 사용자 이상을 지원하려면 시스템을 최적화하고 더 작은 단위의 서비스로 분할해야 할 수 있다.
